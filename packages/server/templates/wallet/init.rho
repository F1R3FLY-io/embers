new doTransfer,
    updateTransferHistory,
    history
in {
    contract doTransfer(@wallet_address_from, @wallet_address_to, @amount, ret) = {
        new rl(`rho:registry:lookup`),
            RevVaultCh in {
            rl!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh) {
                new vaultCh,
                    vaultTo,
                    revVaultKeyCh,
                    deployerId(`rho:rchain:deployerId`) in {
                        @RevVault!("findOrCreate", wallet_address_from, *vaultCh) |
                        @RevVault!("findOrCreate", wallet_address_to, *vaultTo) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultKeyCh) |
                        for (@vault <- vaultCh; @key <- revVaultKeyCh; @vaultToResult <- vaultTo) {
                            match vault {
                                (true, vaultFrom) => {
                                    match vaultToResult {
                                        (true, _) => {
                                            new resultCh in {
                                                @vaultFrom!("transfer", wallet_address_to, amount, key, *resultCh) |
                                                for (@result <- resultCh) {
                                                    match result {
                                                        (true , _  ) => ret!((true, "OK"))
                                                        (false, err) => ret!((false, err))
                                                    }
                                                }
                                            }
                                        }
                                        (false, err) => {
                                            ret!((false, "Destination REV vault cannot be found or created"))
                                        }
                                    }
                                }
                                (false, err) => {
                                    ret!((false, "Source REV vault cannot be found or created"))
                                }
                            }
                        }
                }
            }
        }
    }|

    contract updateTransferHistory(@id, @user, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        for(@transaction_history <- @{ *history | user }) {
            match transaction_history {
                Nil => @{ *history | user }!([{
                    "id": id,
                    "from": wallet_address_from,
                    "to": wallet_address_to,
                    "amount": amount,
                    "description": description
                }])
                value => @{ *history | user }!(value ++ [{
                    "id": id,
                    "from": wallet_address_from,
                    "to": wallet_address_to,
                    "amount": amount,
                    "description": description
                }])
            }
        }
    }|

    contract @"sendTokens"(@id, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        new return in {
            doTransfer!(wallet_address_from, wallet_address_to, amount, *return)|
            for (@v <- return) {
                match v {
                    (true, _) => {
                        updateTransferHistory!(id, wallet_address_from, wallet_address_from, wallet_address_to, amount, description) |
                        updateTransferHistory!(id, wallet_address_to, wallet_address_from, wallet_address_to, amount, description)
                    }
                    (false, err) => return!((false, err))
                }
            }
        }
    }|

    contract @"getTransactionsHistory"(@wallet_address, ret) = {
        for(@transactions <- @{ *history | wallet_address }) {
            match transactions {
                Nil => ret!([])
                value => ret!(value)
            }
        }
    }|

    contract @"getBalance"(@wallet_address, ret) = {
        new rl(`rho:registry:lookup`), RevVaultCh, vaultCh in {
            rl!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh) {
                @RevVault!("findOrCreate", wallet_address, *vaultCh) |
                for (@maybeVault <- vaultCh) {
                    match maybeVault {
                        (true, vault) => {
                            new balanceCh in {
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                        (false, err) => ret!((false, err))
                    }
                }
            }
        }
    }
}
