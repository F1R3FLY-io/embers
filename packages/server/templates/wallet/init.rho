new rl(`rho:registry:lookup`),
    treeHashMapCh,
    getValueOr,
    revVaultCh,
    doTransfer,
    updateTransferHistory
in {
  rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |

  for(treeHashMap <- treeHashMapCh) {
    treeHashMap!("init", 3, *treeHashMapCh) |

    for(map <- treeHashMapCh) {
      treeHashMapCh!(*treeHashMap, *map)
    }
  } |

  contract getValueOr(@address, valueCh, nilCh) = {
    new retCh in {
      for(treeHashMap, map <<- treeHashMapCh) {
        treeHashMap!("get", *map, address, *retCh) |

        for(@value <- retCh) {
          match value {
            Nil => nilCh!()
            value => valueCh!(value)
          }
        }
      }
    }
  } |

  rl!(`rho:rchain:revVault`, *revVaultCh) |

  for (@(_, revVault) <- revVaultCh) {
    revVaultCh!(revVault)
  } |

  contract doTransfer(@deployerId, @wallet_address_from, @wallet_address_to, @amount, ret) = {
    new vaultCh, vaultToCh, revVaultkeyCh, resultCh in {
      for (revVault <<- revVaultCh) {
        revVault!("findOrCreate", wallet_address_from, *vaultCh) |
        revVault!("findOrCreate", wallet_address_to, *vaultToCh) |
        revVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |

        for (@(true, vault) <- vaultCh; key <- revVaultkeyCh; _ <- vaultToCh) {
          @vault!("transfer", wallet_address_to, amount, *key, *resultCh) |

          for (@(true , _) <- resultCh) {
            ret!((true, Nil))
          } |

          for(@(false, err) <- resultCh) {
            ret!((false, "Transfer failed: " ++ err))
          }
        } |

        for(@(false, err) <- vaultCh) {
          ret!((false, "REV vault cannot be found or created: " ++ err))
        }
      }
    }
  } |

  contract updateTransferHistory(@id, @wallet_owner, @wallet_address_from, @wallet_address_to, @amount, @description) = {
    new valueCh, nilCh, retCh in {
      getValueOr!(wallet_owner, *valueCh, *nilCh) |

      for(<- nilCh; treeHashMap, map <<- treeHashMapCh) {
        treeHashMap!("set", *map, wallet_owner,
          [{
            "id": id,
            "from": wallet_address_from,
            "to": wallet_address_to,
            "amount": amount,
            "description": description
          }],
          *retCh)
      } |

      for(@transactionsHistory <- valueCh; treeHashMap, map <<- treeHashMapCh) {
        treeHashMap!("set", *map, wallet_owner,
          transactionsHistory ++ [{
            "id": id,
            "from": wallet_address_from,
            "to": wallet_address_to,
            "amount": amount,
            "description": description
          }],
          *retCh)
      }
    }
  } |

  contract @"sendTransfer"(@deployerId, @id, @wallet_address_from, @wallet_address_to, @amount, @description) = {
    new retCh, debug(`rho:io:stdout`) in {
      doTransfer!(deployerId, wallet_address_from, wallet_address_to, amount, *retCh) |

      for (@(true, _) <- retCh) {
        updateTransferHistory!(id, wallet_address_from, wallet_address_from, wallet_address_to, amount, description) |
        updateTransferHistory!(id, wallet_address_to,   wallet_address_from, wallet_address_to, amount, description)
      } |

      for (@(false, err) <- retCh) {
        debug!("Transfer failed: " ++ err)
      }
    }
  } |

  contract @"getTransactionsHistory"(@wallet_address, ret) = {
    new valueCh, nilCh in {
      getValueOr!(wallet_address, *valueCh, *nilCh) |

      for(<- nilCh) {
        ret!([])
      } |

      for(@transactionsHistory <- valueCh) {
        ret!(transactionsHistory)
      }
    }
  } |

  contract @"getBalance"(@wallet_address, ret) = {
    new vaultCh in {
      for (revVault <<- revVaultCh) {
        revVault!("findOrCreate", wallet_address, *vaultCh) |

        for (@(true, vault) <- vaultCh) {
          @vault!("balance", *ret)
        } |

        for(@(false, err) <- vaultCh) {
          ret!((false, "REV vault cannot be found: " ++ err))
        }
      }
    }
  }
}
