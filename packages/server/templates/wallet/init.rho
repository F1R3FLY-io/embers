new doTransfer,
    updateTransferHistory,
    treeHashMapCh,
    getValueOr,
    rl(`rho:registry:lookup`)
in {
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh)|

    for(treeHashMap <- treeHashMapCh) {
        treeHashMap!("init", 3, *treeHashMapCh)|
        for(map <- treeHashMapCh) {
            treeHashMapCh!(*treeHashMap, *map)
        }
    }|

    contract getValueOr(@address, valueCh, nilCh) = {
        new retCh in {
            for(treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("get", *map, address, *retCh)|

                for(@value <- retCh) {
                    match value {
                        Nil => nilCh!()
                        value => valueCh!(value)
                    }
                }
            }
        }
    }|

    contract doTransfer(@wallet_address_from, @wallet_address_to, @amount, ret) = {
        new rl(`rho:registry:lookup`), RevVaultCh in {
            rl!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh) {
                new vaultCh,
                    vaultTo,
                    revVaultKeyCh,
                    deployId(`rho:rchain:deployId`),
                    deployerId(`rho:rchain:deployerId`) in {
                        @RevVault!("findOrCreate", wallet_address_from, *vaultCh) |
                        @RevVault!("findOrCreate", wallet_address_to, *vaultTo) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultKeyCh) |
                        for (@vault <- vaultCh; @key <- revVaultKeyCh; _ <- vaultTo) {
                            match vault {
                                (true, vault) => {
                                    new resultCh in {
                                        @vault!("transfer", wallet_address_to, amount, key, *resultCh) |
                                        for (@result <- resultCh) {
                                            match result {
                                                (true , _  ) => {
                                                    ret!((true, "OK")) |
                                                    deployId!((true, "OK"))
                                                }
                                                (false, err) => {
                                                    ret!((false, err)) |
                                                    deployId!((false, err))
                                                }
                                            }
                                        }
                                    }
                                }
                                err => {
                                    deployId!((false, "REV vault cannot be found or created")) |
                                    ret!((false, "Source REV vault cannot be found or created"))
                                }
                            }
                        }
                    }
                }
            }
    }|

    contract updateTransferHistory(@id, @wallet_owner, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        new valueCh, nilCh, retCh in {
            getValueOr!(wallet_owner, *valueCh, *nilCh)|

            for(<- nilCh; treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("set", *map, wallet_owner,
                    [{
                        "id": id,
                        "from": wallet_address_from,
                        "to": wallet_address_to,
                        "amount": amount,
                        "description": description }],
                    *retCh)
            }|

            for(@transactionsHistory <- valueCh; treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("set", *map, wallet_owner,
                    transactionsHistory ++ [{
                            "id": id,
                            "from": wallet_address_from,
                            "to": wallet_address_to,
                            "amount": amount,
                            "description": description }],
                    *retCh)
            }
        }
    }|

    contract @"sendTokens"(@id, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        new print(`rho:io:stdout`), next in {
            doTransfer!(wallet_address_from, wallet_address_to, amount, *next) |
            for (@transaction_status <- next) {
                match transaction_status {
                    (true, _) => {
                        updateTransferHistory!(id, wallet_address_from, wallet_address_from, wallet_address_to, amount, description) |
                        updateTransferHistory!(id, wallet_address_to, wallet_address_from, wallet_address_to, amount, description)
                    }
                    (false, err) => {
                        print!("Transfer failed: " ++ err)
                    }
                }
            }
        }
    }|

    contract @"getTransactionsHistory"(@wallet_address, ret) = {
        new valueCh, nilCh in {
            getValueOr!(wallet_address, *valueCh, *nilCh)|

            for(<- nilCh) {
                ret!([])
            }|

            for(@transactionsHistory <- valueCh) {
                ret!(transactionsHistory)
            }
        }
    }|

    contract @"getBalance"(@wallet_address, ret) = {
        new rl(`rho:registry:lookup`), RevVaultCh, vaultCh in {
            rl!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh) {
                @RevVault!("findOrCreate", wallet_address, *vaultCh) |
                for (@maybeVault <- vaultCh) {
                    match maybeVault {
                        (true, vault) => {
                            new balanceCh in {
                                @vault!("balance", *balanceCh) |
                                for (@balance <- balanceCh) {
                                    ret!(balance)
                                }
                            }
                        }
                        (false, err) => ret!((false, err))
                    }
                }
            }
        }
    }
}
