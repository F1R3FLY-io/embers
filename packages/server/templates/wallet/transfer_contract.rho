new doTransfer,
    updateTransferHistory,
    history
in {
    contract doTransfer(@wallet_address_from, @wallet_address_to, @amount, ret) = {
        new rl(`rho:registry:lookup`),
            RevVaultCh in {
            rl!(`rho:rchain:revVault`, *RevVaultCh) |
            for (@(_, RevVault) <- RevVaultCh) {
                new vaultCh,
                    vaultTo,
                    revVaultKeyCh,
                    deployerId(`rho:rchain:deployerId`) in {
                        @RevVault!("findOrCreate", wallet_address_from, *vaultCh) |
                        @RevVault!("findOrCreate", wallet_address_to, *vaultTo) |
                        @RevVault!("deployerAuthKey", *deployerId, *revVaultKeyCh) |
                        for (@vault <- vaultCh; key <- revVaultKeyCh; _ <- vaultTo) {
                            match vault {
                                (true, vault) => {
                                    new resultCh in {
                                        @vault!("transfer", wallet_address_to, amount, *key, *resultCh) |
                                        for (@result <- resultCh) {
                                            match result {
                                                (true , _  ) => ret!((true, "OK"))
                                                (false, err) => ret!((false, err))
                                            }
                                        }
                                    }
                                }
                                err => {
                                    ret!((false, "REV vault cannot be found or created"))
                                }
                            }
                        }
                }
            }
        }
    }|

    contract updateTransferHistory(@id, @user, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        for(@user_transaction_history <- @{ *history | user }) {
            match user_transaction_history {
                Nil => @{ *history | user }!([{
                    "id": id,
                    "from": wallet_address_from,
                    "to": wallet_address_to,
                    "amount": amount,
                    "description": description,
                }])
                value => @{ *history | user }!(value ++ [{
                    "id": id,
                    "from": wallet_address_from,
                    "to": wallet_address_to,
                    "amount": amount,
                    "description": description,
                }])
            }
        }
    }|

    contract @"sendTokens"(@id, @wallet_address_from, @wallet_address_to, @amount, @description) = {
        new return in {
            doTransfer!(wallet_address_from, wallet_address_to, amount, *return)|
            for (@v <- return) {
                match v {
                    (true, _) =>{
                        updateTransferHistory!(id, wallet_address_from, wallet_address_to, amount, description) |
                        updateTransferHistory!(id, wallet_address_to, wallet_address_from, amount, description)
                    }
                    (false, err) => return!((false, err))
                }

            }
        }
    }|

    contract @"getUserHistory"(@wallet_address, ret) = {
        for(@user_transaction_history <- @{ *history | wallet_address }) {
            match user_transaction_history {
                Nil => ret!([])
                value => ret!(user_transaction_history)
            }
        }
    }
}
