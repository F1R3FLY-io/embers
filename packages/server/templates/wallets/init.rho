new rl(`rho:registry:lookup`),
    treeHashMapCh,
    getValueOr,
    revVaultCh,
    eitherCh,
    okOrAbort,
    doTransfer,
    updateTransferHistory,
    getTransactionsHistory,
    getBalance
in {
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |

    for(treeHashMap <- treeHashMapCh) {
        treeHashMap!("init", 3, *treeHashMapCh) |

        for(map <- treeHashMapCh) {
            treeHashMapCh!(*treeHashMap, *map)
        }
    } |

    contract getValueOr(@address, valueCh, nilCh) = {
        new retCh in {
            for(treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("get", *map, address, *retCh) |

                for(@value <- retCh) {
                    match value {
                        Nil => nilCh!()
                        value => valueCh!(value)
                    }
                }
            }
        }
    } |

    rl!(`rho:rchain:revVault`, *revVaultCh) |

    for(@(_, revVault) <- revVaultCh) {
        revVaultCh!(revVault)
    } |

    rl!(`rho:lang:either`, *eitherCh) |

    for(@(_, either) <- eitherCh) {
        eitherCh!(either)
    } |

    contract okOrAbort(eitherCh, f, @log, return) = {
        new debug(`rho:io:stdout`) in {
            for(@either <- eitherCh) {
                match either {
                    (true, v) => f!(v, *return)
                    (false, err) => debug!([log, err])
                }
            }
        }
    } |

    contract doTransfer(@deployerId, @walletAddressFrom, @walletAddressTo, @amount, ret) = {
        new vaultCh, vaultToCh, revVaultkeyCh, transferOp in {
            for(revVault <<- revVaultCh) {
                revVault!("findOrCreate", walletAddressFrom, *vaultCh) |
                revVault!("findOrCreate", walletAddressTo, *vaultToCh) |
                revVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |

                for(either <<- eitherCh; key <- revVaultkeyCh; _ <- vaultToCh) {
                    for(vault, return <- transferOp) {
                        vault!("transfer", walletAddressTo, amount, *key, *return)
                    } |

                    either!("flatMap <-", *vaultCh, *transferOp, *ret)
                }
            }
        }
    } |

    contract updateTransferHistory(@walletOwner, @id, @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new valueCh, nilCh, done in {
            getValueOr!(walletOwner, *valueCh, *nilCh) |

            for(<- nilCh; treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("set", *map, walletOwner,
                    [{
                        "id": id,
                        "timestamp": timestamp,
                        "from": walletAddressFrom,
                        "to": walletAddressTo,
                        "amount": amount,
                        "description": description
                    }],
                    *done)
            } |

            for(@transactionsHistory <- valueCh; treeHashMap, map <<- treeHashMapCh) {
                treeHashMap!("set", *map, walletOwner,
                    transactionsHistory ++ [{
                        "id": id,
                        "timestamp": timestamp,
                        "from": walletAddressFrom,
                        "to": walletAddressTo,
                        "amount": amount,
                        "description": description
                    }],
                    *done)
            }
        }
    } |

    contract @"sendTransfer"(@deployerId, @id, @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new transferResultCh, updateHistory, done in {
            for(either <<- eitherCh) {
                doTransfer!(deployerId, walletAddressFrom, walletAddressTo, amount, *transferResultCh) |

                for(@v, return <- updateHistory) {
                    updateTransferHistory!(walletAddressFrom, id, timestamp, walletAddressFrom, walletAddressTo, amount, description) |
                    updateTransferHistory!(walletAddressTo  , id, timestamp, walletAddressFrom, walletAddressTo, amount, description) |
                    return!(v)
                } |

                okOrAbort!(*transferResultCh, *updateHistory, "transfer failed", *done)
            }
        }
    } |

    contract getTransactionsHistory(@walletAddress, ret) = {
        new valueCh, nilCh in {
            getValueOr!(walletAddress, *valueCh, *nilCh) |

            for(<- nilCh) {
                ret!([])
            } |

            for(@transactionsHistory <- valueCh) {
                ret!(transactionsHistory)
            }
        }
    } |

    contract getBalance(@walletAddress, ret) = {
        new vaultCh, balanceOp in {
            for(revVault <<- revVaultCh; either <<- eitherCh) {
                revVault!("findOrCreate", walletAddress, *vaultCh) |

                for(vault, return <- balanceOp) {
                    vault!("balance", *return)
                } |

                either!("map <-", *vaultCh, *balanceOp, *ret)
            }
        }
    } |

    contract @"getBalanceAndHistory"(@walletAddress, ret) = {
        new balanceCh, historyCh, mapOp in {
            for(either <<- eitherCh) {
                getBalance!(walletAddress, *balanceCh) |
                getTransactionsHistory!(walletAddress, *historyCh) |

                for(@balance, return <- mapOp; @history <- historyCh) {
                    return!({"balance": balance, "history": history})
                } |

                either!("map <-", *balanceCh, *mapOp, *ret)
            }
        }
    }
}
