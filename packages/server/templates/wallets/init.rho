{% extends "common/insert_signed.rho" %}

{% block name -%} wallets {%- endblock %}

{% block initialization -%}
{% filter indent(8) -%}

new rl(`rho:registry:lookup`),
    treeHashMapCh,
    revVaultCh,
    eitherCh,
    stackCh,
    abort(`rho:execution:abort`),
    devNull(`rho:io:devNull`),
    okOrAbort,
    doTransfer,
    updateTransferHistory,
    getTransactionsHistory,
    getBalance
in {
    rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |
    for(treeHashMap <- treeHashMapCh) {
        treeHashMap!("init", 3, *treeHashMapCh) |

        for(@map <- treeHashMapCh) {
            treeHashMapCh!(*treeHashMap, map)
        }
    } |

    rl!(`rho:rchain:revVault`, *revVaultCh) |
    for(@(_, revVault) <- revVaultCh) {
        revVaultCh!(revVault)
    } |

    rl!(`rho:lang:either`, *eitherCh) |
    for(@(_, either) <- eitherCh) {
        eitherCh!(either)
    } |

    rl!(`rho:lang:stack`, *stackCh) |
    for(@(_, stack) <- stackCh) {
        stackCh!(stack)
    } |

    contract okOrAbort(eitherCh, f, @log) = {
        for(@either <- eitherCh) {
            match either {
                (true, v) => f!(v)
                (false, err) => abort!([log, err])
            }
        }
    } |

    contract doTransfer(@deployerId, @walletAddressFrom, @walletAddressTo, @amount, @ret) = {
        new vaultCh, vaultToCh, revVaultkeyCh, transferOp in {
            for(revVault <<- revVaultCh) {
                revVault!("findOrCreate", walletAddressFrom, *vaultCh) |
                revVault!("findOrCreate", walletAddressTo, *vaultToCh) |
                revVault!("deployerAuthKey", deployerId, *revVaultkeyCh) |

                for(@key <- revVaultkeyCh; _ <- vaultToCh; either <<- eitherCh) {
                    for(vault, @return <- transferOp) {
                        vault!("transfer", walletAddressTo, amount, key, return)
                    } |

                    either!("flatMap <-", *vaultCh, *transferOp, ret)
                }
            }
        }
    } |

    contract updateTransferHistory(@walletOwner, @id, @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new valueCh, nilCh in {
            for(treeHashMap, @map <<- treeHashMapCh; stack <<- stackCh) {
                treeHashMap!("getOrElse", map, walletOwner, *valueCh, *nilCh) |

                for(<- nilCh) {
                    new userHistoryCh in {
                        stack!("init", *userHistoryCh) |

                        for(@history <- userHistoryCh) {
                            stack!("push", history, {
                                "id": id,
                                "timestamp": timestamp,
                                "from": walletAddressFrom,
                                "to": walletAddressTo,
                                "amount": amount,
                                "description": description,
                            }, *devNull) |
                            treeHashMap!("set", map, walletOwner, history, *devNull)
                        }
                    }
                } |

                for(@history <- valueCh) {
                    stack!("push", history, {
                        "id": id,
                        "timestamp": timestamp,
                        "from": walletAddressFrom,
                        "to": walletAddressTo,
                        "amount": amount,
                        "description": description,
                    }, *devNull)
                }
            }
        }
    } |

    contract wallets(@"sendTransfer", @timestamp, @walletAddressFrom, @walletAddressTo, @amount, @description) = {
        new deployData(`rho:deploy:data`), deployDataCh, transferResultCh, updateHistory in {
            deployData!(*deployDataCh) |
            for(either <<- eitherCh; _, @deployerId, @deployId <- deployDataCh) {
                doTransfer!(deployerId, walletAddressFrom, walletAddressTo, amount, *transferResultCh) |

                for(_ <- updateHistory) {
                    updateTransferHistory!(walletAddressFrom, deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description) |
                    updateTransferHistory!(walletAddressTo  , deployId, timestamp, walletAddressFrom, walletAddressTo, amount, description)
                } |

                okOrAbort!(*transferResultCh, *updateHistory, "transfer failed")
            }
        }
    } |

    contract getTransactionsHistory(@walletAddress, ret) = {
        new valueCh, nilCh in {
            for(treeHashMap, @map <<- treeHashMapCh) {
                treeHashMap!("getOrElse", map, walletAddress, *valueCh, *nilCh)
            } |

            for(<- nilCh) {
                ret!([])
            } |

            for(@history <- valueCh; stack <<- stackCh) {
                new listCh in {
                    stack!("toList", history, *listCh) |

                    for(@transactionsHistory <- listCh) {
                        ret!(transactionsHistory)
                    }
                }
            }
        }
    } |

    contract getBalance(@walletAddress, ret) = {
        new vaultCh, balanceOp in {
            for(revVault <<- revVaultCh; either <<- eitherCh) {
                revVault!("findOrCreate", walletAddress, *vaultCh) |

                for(vault, return <- balanceOp) {
                    vault!("balance", *return)
                } |

                either!("map <-", *vaultCh, *balanceOp, *ret)
            }
        }
    } |

    contract wallets(@"getBalanceAndHistory", @walletAddress, ret) = {
        new balanceCh, historyCh, mapOp in {
            for(either <<- eitherCh) {
                getBalance!(walletAddress, *balanceCh) |
                getTransactionsHistory!(walletAddress, *historyCh) |

                for(@balance, return <- mapOp & @history <- historyCh) {
                    return!({"balance": balance, "history": history})
                } |

                either!("map <-", *balanceCh, *mapOp, *ret)
            }
        }
    }
}

{%- endfilter %}
{%- endblock %}
