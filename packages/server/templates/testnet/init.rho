new rl(`rho:registry:lookup`),
    rs(`rho:registry:insertSigned:secp256k1`),
    devNull(`rho:io:devNull`),
    abort(`rho:execution:abort`),
    prevEnvCh,
    initEnv,
    treeHashMapCh,
    stackCh,
    getValueOr,
    log,
    private,
    uriCh
in {
    rl!({{ env_uri }}, *prevEnvCh) |

    for(@Nil <- prevEnvCh) {
        initEnv!()
    } |

    for(@(nonce, _) <- prevEnvCh) {
        if (nonce < {{ nonce }}) {
            initEnv!()
        }
    } |

    for(<- initEnv) {
        rl!(`rho:lang:treeHashMap`, *treeHashMapCh) |
        for(treeHashMap <- treeHashMapCh) {
            treeHashMap!("init", 3, *treeHashMapCh) |

            for(@map <- treeHashMapCh) {
                treeHashMapCh!(*treeHashMap, map)
            }
        } |

        rl!(`rho:lang:stack`, *stackCh) |
        for(@(_, stack) <- stackCh) {
            stackCh!(stack)
        } |

        contract getValueOr(@address, valueCh, nilCh) = {
            new retCh in {
                for(treeHashMap, @map <<- treeHashMapCh) {
                    treeHashMap!("get", map, address, *retCh) |

                    for(@value <- retCh) {
                        match value {
                            Nil => nilCh!()
                            value => valueCh!(value)
                        }
                    }
                }
            }
        } |

        contract @(*log, *private)(@level, @message) = {
            new deployData(`rho:deploy:data`), deployDataCh, valueCh, nilCh, logsCh in {
                deployData!(*deployDataCh) |

                for(_, _, @deployId <- deployDataCh) {
                    getValueOr!(deployId.toString(), *valueCh, *nilCh) |

                    for(@logs <- valueCh; stack <<- stackCh) {
                        stack!("push", logs, {"level": level, "message": message}, *devNull)
                    } |

                    for(<- nilCh; treeHashMap, @map <<- treeHashMapCh; stack <<- stackCh) {
                        stack!("init", *logsCh) |

                        for(@logs <- logsCh) {
                            stack!("push", logs, {"level": level, "message": message}, *devNull) |
                            treeHashMap!("set", map, deployId.toString(), logs, *devNull)
                        }
                    }
                }
            }
        } |

        contract log(@"debug", @message) = {
            @(*log, *private)!("debug", message)
        } |

        contract log(@"info", @message) = {
            @(*log, *private)!("info", message)
        } |

        contract log(@"error", @message) = {
            @(*log, *private)!("error", message)
        } |

        contract log(@"get", @deployId, ret) = {
            new valueCh, nilCh in {
                for(@logs <- valueCh; stack <<- stackCh) {
                    stack!("toList", logs, *ret)
                } |

                for(<- nilCh) {
                    ret!(Nil)
                } |

                getValueOr!(deployId, *valueCh, *nilCh)
            }
        } |

        rs!(
            {{ public_key }},
            ({{ nonce }}, bundle+{*log}),
            {{ sig }},
            *uriCh
        ) |

        for(@Nil <- uriCh) {
            abort!("failed to insert test env")
        }
    }
}
