# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: RhoTypes.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "BindPattern",
    "Bundle",
    "Connective",
    "ConnectiveBody",
    "DeployId",
    "DeployerId",
    "EAnd",
    "EDiv",
    "EEq",
    "EGt",
    "EGte",
    "EList",
    "ELt",
    "ELte",
    "EMap",
    "EMatches",
    "EMethod",
    "EMinus",
    "EMinusMinus",
    "EMod",
    "EMult",
    "ENeg",
    "ENeq",
    "ENot",
    "EOr",
    "EPercentPercent",
    "EPlus",
    "EPlusPlus",
    "ESet",
    "ETuple",
    "EVar",
    "Expr",
    "GDeployId",
    "GDeployerId",
    "GPrivate",
    "GSysAuthToken",
    "GUnforgeable",
    "KeyValuePair",
    "ListBindPatterns",
    "ListParWithRandom",
    "Match",
    "MatchCase",
    "New",
    "PCost",
    "Par",
    "ParWithRandom",
    "Receive",
    "ReceiveBind",
    "Send",
    "TaggedContinuation",
    "Var",
    "VarRef",
    "VarWildcardMsg",
)

from dataclasses import dataclass

import betterproto2

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class BindPattern(betterproto2.Message):
    patterns: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    remainder: "Var | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    free_count: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)


default_message_pool.register_message("rhoapi", "BindPattern", BindPattern)


@dataclass(eq=False, repr=False)
class Bundle(betterproto2.Message):
    """
    *
    Nothing can be received from a (quoted) bundle with `readFlag = false`.
    Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.

    If both flags are set to false, bundle allows only for equivalance check.
    """

    body: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    write_flag: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)
    """
    flag indicating whether bundle is writeable
    """

    read_flag: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)
    """
    flag indicating whether bundle is readable
    """


default_message_pool.register_message("rhoapi", "Bundle", Bundle)


@dataclass(eq=False, repr=False)
class Connective(betterproto2.Message):
    """


    Oneofs:
        - connective_instance:
    """

    conn_and_body: "ConnectiveBody | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="connective_instance"
    )

    conn_or_body: "ConnectiveBody | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="connective_instance"
    )

    conn_not_body: "Par | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="connective_instance"
    )

    var_ref_body: "VarRef | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="connective_instance"
    )

    conn_bool: "bool | None" = betterproto2.field(5, betterproto2.TYPE_BOOL, optional=True, group="connective_instance")

    conn_int: "bool | None" = betterproto2.field(6, betterproto2.TYPE_BOOL, optional=True, group="connective_instance")

    conn_string: "bool | None" = betterproto2.field(
        7, betterproto2.TYPE_BOOL, optional=True, group="connective_instance"
    )

    conn_uri: "bool | None" = betterproto2.field(8, betterproto2.TYPE_BOOL, optional=True, group="connective_instance")

    conn_byte_array: "bool | None" = betterproto2.field(
        9, betterproto2.TYPE_BOOL, optional=True, group="connective_instance"
    )


default_message_pool.register_message("rhoapi", "Connective", Connective)


@dataclass(eq=False, repr=False)
class ConnectiveBody(betterproto2.Message):
    ps: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("rhoapi", "ConnectiveBody", ConnectiveBody)


@dataclass(eq=False, repr=False)
class DeployerId(betterproto2.Message):
    public_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "DeployerId", DeployerId)


@dataclass(eq=False, repr=False)
class DeployId(betterproto2.Message):
    sig: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "DeployId", DeployId)


@dataclass(eq=False, repr=False)
class EAnd(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EAnd", EAnd)


@dataclass(eq=False, repr=False)
class EDiv(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EDiv", EDiv)


@dataclass(eq=False, repr=False)
class EEq(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EEq", EEq)


@dataclass(eq=False, repr=False)
class EGt(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EGt", EGt)


@dataclass(eq=False, repr=False)
class EGte(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EGte", EGte)


@dataclass(eq=False, repr=False)
class EList(betterproto2.Message):
    ps: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)

    remainder: "Var | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EList", EList)


@dataclass(eq=False, repr=False)
class ELt(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ELt", ELt)


@dataclass(eq=False, repr=False)
class ELte(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ELte", ELte)


@dataclass(eq=False, repr=False)
class EMap(betterproto2.Message):
    kvs: "list[KeyValuePair]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)

    remainder: "Var | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMap", EMap)


@dataclass(eq=False, repr=False)
class EMatches(betterproto2.Message):
    target: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    pattern: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMatches", EMatches)


@dataclass(eq=False, repr=False)
class EMethod(betterproto2.Message):
    """
    *
    `target.method(arguments)`
    """

    method_name: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    target: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    arguments: "list[Par]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "EMethod", EMethod)


@dataclass(eq=False, repr=False)
class EMinus(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMinus", EMinus)


@dataclass(eq=False, repr=False)
class EMinusMinus(betterproto2.Message):
    """
    Set difference
    """

    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMinusMinus", EMinusMinus)


@dataclass(eq=False, repr=False)
class EMod(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMod", EMod)


@dataclass(eq=False, repr=False)
class EMult(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EMult", EMult)


@dataclass(eq=False, repr=False)
class ENeg(betterproto2.Message):
    p: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ENeg", ENeg)


@dataclass(eq=False, repr=False)
class ENeq(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ENeq", ENeq)


@dataclass(eq=False, repr=False)
class ENot(betterproto2.Message):
    p: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ENot", ENot)


@dataclass(eq=False, repr=False)
class EOr(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EOr", EOr)


@dataclass(eq=False, repr=False)
class EPercentPercent(betterproto2.Message):
    """
    *
    String interpolation

    `"Hello, {name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
    """

    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EPercentPercent", EPercentPercent)


@dataclass(eq=False, repr=False)
class EPlus(betterproto2.Message):
    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EPlus", EPlus)


@dataclass(eq=False, repr=False)
class EPlusPlus(betterproto2.Message):
    """
    Concatenation
    """

    p1: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    p2: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EPlusPlus", EPlusPlus)


@dataclass(eq=False, repr=False)
class ESet(betterproto2.Message):
    ps: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)

    remainder: "Var | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "ESet", ESet)


@dataclass(eq=False, repr=False)
class ETuple(betterproto2.Message):
    ps: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "ETuple", ETuple)


@dataclass(eq=False, repr=False)
class EVar(betterproto2.Message):
    """
    A variable used as a var should be bound in a process context, not a name
    context. For example:
    `for (@x <- c1; @y <- c2) { z!(x + y) }` is fine, but
    `for (x <- c1; y <- c2) { z!(x + y) }` should raise an error.
    """

    v: "Var | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "EVar", EVar)


@dataclass(eq=False, repr=False)
class Expr(betterproto2.Message):
    """
    Any process may be an operand to an expression.
    Only processes equivalent to a ground process of compatible type will reduce.

    Oneofs:
        - expr_instance:
    """

    g_bool: "bool | None" = betterproto2.field(1, betterproto2.TYPE_BOOL, optional=True, group="expr_instance")

    g_int: "int | None" = betterproto2.field(2, betterproto2.TYPE_SINT64, optional=True, group="expr_instance")

    g_string: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True, group="expr_instance")

    g_uri: "str | None" = betterproto2.field(4, betterproto2.TYPE_STRING, optional=True, group="expr_instance")

    g_byte_array: "bytes | None" = betterproto2.field(25, betterproto2.TYPE_BYTES, optional=True, group="expr_instance")

    e_not_body: "ENot | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_neg_body: "ENeg | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_mult_body: "EMult | None" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_div_body: "EDiv | None" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_plus_body: "EPlus | None" = betterproto2.field(9, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_minus_body: "EMinus | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )

    e_lt_body: "ELt | None" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_lte_body: "ELte | None" = betterproto2.field(12, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_gt_body: "EGt | None" = betterproto2.field(13, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_gte_body: "EGte | None" = betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_eq_body: "EEq | None" = betterproto2.field(15, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_neq_body: "ENeq | None" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_and_body: "EAnd | None" = betterproto2.field(17, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_or_body: "EOr | None" = betterproto2.field(18, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_var_body: "EVar | None" = betterproto2.field(19, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_list_body: "EList | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )

    e_tuple_body: "ETuple | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )

    e_set_body: "ESet | None" = betterproto2.field(22, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_map_body: "EMap | None" = betterproto2.field(23, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")

    e_method_body: "EMethod | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )

    e_matches_body: "EMatches | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )

    e_percent_percent_body: "EPercentPercent | None" = betterproto2.field(
        28, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )
    """
    string interpolation
    """

    e_plus_plus_body: "EPlusPlus | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )
    """
    concatenation
    """

    e_minus_minus_body: "EMinusMinus | None" = betterproto2.field(
        30, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance"
    )
    """
    set difference
    """

    e_mod_body: "EMod | None" = betterproto2.field(31, betterproto2.TYPE_MESSAGE, optional=True, group="expr_instance")


default_message_pool.register_message("rhoapi", "Expr", Expr)


@dataclass(eq=False, repr=False)
class GDeployerId(betterproto2.Message):
    public_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "GDeployerId", GDeployerId)


@dataclass(eq=False, repr=False)
class GDeployId(betterproto2.Message):
    sig: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "GDeployId", GDeployId)


@dataclass(eq=False, repr=False)
class GPrivate(betterproto2.Message):
    id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "GPrivate", GPrivate)


@dataclass(eq=False, repr=False)
class GSysAuthToken(betterproto2.Message):
    pass


default_message_pool.register_message("rhoapi", "GSysAuthToken", GSysAuthToken)


@dataclass(eq=False, repr=False)
class GUnforgeable(betterproto2.Message):
    """
    Unforgeable names resulting from `new x { ... }`
    These should only occur as the program is being evaluated. There is no way in
    the grammar to construct them.

    Oneofs:
        - unf_instance:
    """

    g_private_body: "GPrivate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="unf_instance"
    )

    g_deploy_id_body: "GDeployId | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="unf_instance"
    )

    g_deployer_id_body: "GDeployerId | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="unf_instance"
    )

    g_sys_auth_token_body: "GSysAuthToken | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="unf_instance"
    )


default_message_pool.register_message("rhoapi", "GUnforgeable", GUnforgeable)


@dataclass(eq=False, repr=False)
class KeyValuePair(betterproto2.Message):
    key: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    value: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("rhoapi", "KeyValuePair", KeyValuePair)


@dataclass(eq=False, repr=False)
class ListBindPatterns(betterproto2.Message):
    patterns: "list[BindPattern]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("rhoapi", "ListBindPatterns", ListBindPatterns)


@dataclass(eq=False, repr=False)
class ListParWithRandom(betterproto2.Message):
    pars: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    random_state: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "ListParWithRandom", ListParWithRandom)


@dataclass(eq=False, repr=False)
class Match(betterproto2.Message):
    target: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    cases: "list[MatchCase]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "Match", Match)


@dataclass(eq=False, repr=False)
class MatchCase(betterproto2.Message):
    pattern: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    source: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    free_count: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)


default_message_pool.register_message("rhoapi", "MatchCase", MatchCase)


@dataclass(eq=False, repr=False)
class New(betterproto2.Message):
    """
    Number of variables bound in the new statement.
    For normalized form, p should not contain solely another new.
    Also for normalized form, the first use should be level+0, next use level+1
    up to level+count for the last used variable.
    """

    bind_count: "int" = betterproto2.field(1, betterproto2.TYPE_SINT32)
    """
    Includes any uris listed below. This makes it easier to substitute or walk a term.
    """

    p: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    uri: "list[str]" = betterproto2.field(3, betterproto2.TYPE_STRING, repeated=True)
    """
    For normalization, uri-referenced variables come at the end, and in lexicographical order.
    """

    injections: "dict[str, Par]" = betterproto2.field(
        4, betterproto2.TYPE_MAP, map_meta=betterproto2.map_meta(betterproto2.TYPE_STRING, betterproto2.TYPE_MESSAGE)
    )

    locally_free: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "New", New)


@dataclass(eq=False, repr=False)
class Par(betterproto2.Message):
    """
    *
    Rholang process

    For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
    and one receive.

    The Nil process is a `Par` with no sends, receives, etc.
    """

    sends: "list[Send]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    receives: "list[Receive]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    news: "list[New]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)

    exprs: "list[Expr]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)

    matches: "list[Match]" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, repeated=True)

    unforgeables: "list[GUnforgeable]" = betterproto2.field(7, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    unforgeable names
    """

    bundles: "list[Bundle]" = betterproto2.field(11, betterproto2.TYPE_MESSAGE, repeated=True)

    connectives: "list[Connective]" = betterproto2.field(8, betterproto2.TYPE_MESSAGE, repeated=True)

    locally_free: "bytes" = betterproto2.field(9, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(10, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "Par", Par)


@dataclass(eq=False, repr=False)
class ParWithRandom(betterproto2.Message):
    """
    *
    Rholang code along with the state of a split random number
    generator for generating new unforgeable names.
    """

    body: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    random_state: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("rhoapi", "ParWithRandom", ParWithRandom)


@dataclass(eq=False, repr=False)
class PCost(betterproto2.Message):
    """
    *
    Cost of the performed operations.
    """

    cost: "int" = betterproto2.field(1, betterproto2.TYPE_UINT64)


default_message_pool.register_message("rhoapi", "PCost", PCost)


@dataclass(eq=False, repr=False)
class Receive(betterproto2.Message):
    """
    *
    A receive is written `for(binds) { body }`
    i.e. `for(patterns <- source) { body }`
    or for a persistent recieve: `for(patterns <= source) { body }`.

    It's an error for free Variable to occur more than once in a pattern.
    """

    binds: "list[ReceiveBind]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    body: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    persistent: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    peek: "bool" = betterproto2.field(4, betterproto2.TYPE_BOOL)

    bind_count: "int" = betterproto2.field(5, betterproto2.TYPE_INT32)

    locally_free: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(7, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "Receive", Receive)


@dataclass(eq=False, repr=False)
class ReceiveBind(betterproto2.Message):
    patterns: "list[Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    source: "Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    remainder: "Var | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    free_count: "int" = betterproto2.field(4, betterproto2.TYPE_INT32)


default_message_pool.register_message("rhoapi", "ReceiveBind", ReceiveBind)


@dataclass(eq=False, repr=False)
class Send(betterproto2.Message):
    """
    *
    A send is written `chan!(data)` or `chan!!(data)` for a persistent send.

    Upon send, all free variables in data are substituted with their values.
    """

    chan: "Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    data: "list[Par]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    persistent: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    locally_free: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)

    connective_used: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)


default_message_pool.register_message("rhoapi", "Send", Send)


@dataclass(eq=False, repr=False)
class TaggedContinuation(betterproto2.Message):
    """
    *
    Either rholang code or code built in to the interpreter.

    Oneofs:
        - tagged_cont:
    """

    par_body: "ParWithRandom | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="tagged_cont"
    )

    scala_body_ref: "int | None" = betterproto2.field(2, betterproto2.TYPE_INT64, optional=True, group="tagged_cont")


default_message_pool.register_message("rhoapi", "TaggedContinuation", TaggedContinuation)


@dataclass(eq=False, repr=False)
class Var(betterproto2.Message):
    """
    While we use vars in both positions, when producing the normalized
    representation we need a discipline to track whether a var is a name or a
    process.
    These are DeBruijn levels

    Oneofs:
        - var_instance:
    """

    bound_var: "int | None" = betterproto2.field(1, betterproto2.TYPE_SINT32, optional=True, group="var_instance")

    free_var: "int | None" = betterproto2.field(2, betterproto2.TYPE_SINT32, optional=True, group="var_instance")

    wildcard: "VarWildcardMsg | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="var_instance"
    )


default_message_pool.register_message("rhoapi", "Var", Var)


@dataclass(eq=False, repr=False)
class VarWildcardMsg(betterproto2.Message):
    pass


default_message_pool.register_message("rhoapi", "Var.WildcardMsg", VarWildcardMsg)


@dataclass(eq=False, repr=False)
class VarRef(betterproto2.Message):
    index: "int" = betterproto2.field(1, betterproto2.TYPE_SINT32)

    depth: "int" = betterproto2.field(2, betterproto2.TYPE_SINT32)


default_message_pool.register_message("rhoapi", "VarRef", VarRef)
