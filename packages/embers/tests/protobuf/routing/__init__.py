# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: routing.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Ack",
    "Chunk",
    "ChunkData",
    "ChunkHeader",
    "Disconnect",
    "Header",
    "Heartbeat",
    "HeartbeatResponse",
    "InternalServerError",
    "Node",
    "Packet",
    "Protocol",
    "ProtocolHandshake",
    "ProtocolHandshakeResponse",
    "TlRequest",
    "TlResponse",
    "TransportLayerStub",
)

from collections.abc import Iterable
from dataclasses import dataclass

import betterproto2
import grpc

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class Ack(betterproto2.Message):
    header: "Header | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("routing", "Ack", Ack)


@dataclass(eq=False, repr=False)
class Chunk(betterproto2.Message):
    """


    Oneofs:
        - content:
    """

    header: "ChunkHeader | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="content")

    data: "ChunkData | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="content")


default_message_pool.register_message("routing", "Chunk", Chunk)


@dataclass(eq=False, repr=False)
class ChunkData(betterproto2.Message):
    content_data: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("routing", "ChunkData", ChunkData)


@dataclass(eq=False, repr=False)
class ChunkHeader(betterproto2.Message):
    sender: "Node | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    type_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    compressed: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    content_length: "int" = betterproto2.field(4, betterproto2.TYPE_INT32)

    network_id: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)


default_message_pool.register_message("routing", "ChunkHeader", ChunkHeader)


@dataclass(eq=False, repr=False)
class Disconnect(betterproto2.Message):
    pass


default_message_pool.register_message("routing", "Disconnect", Disconnect)


@dataclass(eq=False, repr=False)
class Header(betterproto2.Message):
    sender: "Node | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    network_id: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("routing", "Header", Header)


@dataclass(eq=False, repr=False)
class Heartbeat(betterproto2.Message):
    pass


default_message_pool.register_message("routing", "Heartbeat", Heartbeat)


@dataclass(eq=False, repr=False)
class HeartbeatResponse(betterproto2.Message):
    pass


default_message_pool.register_message("routing", "HeartbeatResponse", HeartbeatResponse)


@dataclass(eq=False, repr=False)
class InternalServerError(betterproto2.Message):
    error: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("routing", "InternalServerError", InternalServerError)


@dataclass(eq=False, repr=False)
class Node(betterproto2.Message):
    id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    host: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    tcp_port: "int" = betterproto2.field(3, betterproto2.TYPE_UINT32)

    udp_port: "int" = betterproto2.field(4, betterproto2.TYPE_UINT32)


default_message_pool.register_message("routing", "Node", Node)


@dataclass(eq=False, repr=False)
class Packet(betterproto2.Message):
    type_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    content: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("routing", "Packet", Packet)


@dataclass(eq=False, repr=False)
class Protocol(betterproto2.Message):
    """


    Oneofs:
        - message:
    """

    header: "Header | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    heartbeat: "Heartbeat | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True, group="message")

    protocol_handshake: "ProtocolHandshake | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="message"
    )

    protocol_handshake_response: "ProtocolHandshakeResponse | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="message"
    )

    packet: "Packet | None" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, optional=True, group="message")

    disconnect: "Disconnect | None" = betterproto2.field(6, betterproto2.TYPE_MESSAGE, optional=True, group="message")


default_message_pool.register_message("routing", "Protocol", Protocol)


@dataclass(eq=False, repr=False)
class ProtocolHandshake(betterproto2.Message):
    nonce: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("routing", "ProtocolHandshake", ProtocolHandshake)


@dataclass(eq=False, repr=False)
class ProtocolHandshakeResponse(betterproto2.Message):
    nonce: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("routing", "ProtocolHandshakeResponse", ProtocolHandshakeResponse)


@dataclass(eq=False, repr=False)
class TlRequest(betterproto2.Message):
    protocol: "Protocol | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("routing", "TLRequest", TlRequest)


@dataclass(eq=False, repr=False)
class TlResponse(betterproto2.Message):
    """


    Oneofs:
        - payload:
    """

    ack: "Ack | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True, group="payload")

    internal_server_error: "InternalServerError | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )


default_message_pool.register_message("routing", "TLResponse", TlResponse)


class TransportLayerStub:
    def __init__(self, channel: grpc.Channel):
        self._channel = channel

    def send(self, message: "TlRequest") -> "TlResponse":
        return self._channel.unary_unary(
            "/routing.TransportLayer/Send",
            TlRequest.SerializeToString,
            TlResponse.FromString,
        )(message)

    def stream(self, messages: "Iterable[Chunk]") -> "TlResponse":
        return self._channel.stream_unary(
            "/routing.TransportLayer/Stream",
            Chunk.SerializeToString,
            TlResponse.FromString,
        )(iter(messages))
