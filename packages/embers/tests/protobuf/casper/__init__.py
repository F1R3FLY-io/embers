# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: CasperMessage.proto, DeployServiceCommon.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "ApprovedBlockCandidateProto",
    "ApprovedBlockProto",
    "ApprovedBlockRequestProto",
    "BlockApprovalProto",
    "BlockEventInfo",
    "BlockHashMessageProto",
    "BlockInfo",
    "BlockMessageProto",
    "BlockMetadataInternal",
    "BlockQuery",
    "BlockRequestProto",
    "BlocksQuery",
    "BlocksQueryByHeight",
    "BodyProto",
    "BondInfo",
    "BondProto",
    "BondStatusQuery",
    "CloseBlockSystemDeployDataProto",
    "CommEventProto",
    "ConsumeEventProto",
    "ContinuationAtNameQuery",
    "ContinuationsWithBlockInfo",
    "DataAtNameByBlockQuery",
    "DataAtNameQuery",
    "DataWithBlockInfo",
    "DeployDataProto",
    "DeployInfo",
    "DeployInfoWithEventData",
    "EventProto",
    "ExploratoryDeployQuery",
    "FindDeployQuery",
    "ForkChoiceTipRequestProto",
    "HasBlockProto",
    "HasBlockRequestProto",
    "HeaderProto",
    "IsFinalizedQuery",
    "JustificationInfo",
    "JustificationProto",
    "LastFinalizedBlockQuery",
    "LightBlockInfo",
    "MachineVerifyQuery",
    "NoApprovedBlockAvailableProto",
    "PeekProto",
    "PrivateNamePreviewQuery",
    "ProcessedDeployProto",
    "ProcessedSystemDeployProto",
    "ProduceEventProto",
    "RChainStateProto",
    "RejectedDeployInfo",
    "RejectedDeployProto",
    "ReportCommProto",
    "ReportConsumeProto",
    "ReportProduceProto",
    "ReportProto",
    "ReportQuery",
    "Signature",
    "SingleReport",
    "SlashSystemDeployDataProto",
    "Status",
    "StoreItemProto",
    "StoreItemsMessageProto",
    "StoreItemsMessageRequestProto",
    "StoreNodeKeyProto",
    "SystemDeployDataProto",
    "SystemDeployInfoWithEventData",
    "UnapprovedBlockProto",
    "VersionInfo",
    "VisualizeDagQuery",
    "WaitingContinuationInfo",
)

from dataclasses import dataclass

import betterproto2

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


@dataclass(eq=False, repr=False)
class ApprovedBlockCandidateProto(betterproto2.Message):
    """
    ---------- Signing Protocol ---------
    """

    block: "BlockMessageProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    required_sigs: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "ApprovedBlockCandidateProto", ApprovedBlockCandidateProto)


@dataclass(eq=False, repr=False)
class ApprovedBlockProto(betterproto2.Message):
    candidate: "ApprovedBlockCandidateProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    sigs: "list[Signature]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "ApprovedBlockProto", ApprovedBlockProto)


@dataclass(eq=False, repr=False)
class ApprovedBlockRequestProto(betterproto2.Message):
    identifier: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    trim_state: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message("casper", "ApprovedBlockRequestProto", ApprovedBlockRequestProto)


@dataclass(eq=False, repr=False)
class BlockApprovalProto(betterproto2.Message):
    candidate: "ApprovedBlockCandidateProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    sig: "Signature | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "BlockApprovalProto", BlockApprovalProto)


@dataclass(eq=False, repr=False)
class BlockEventInfo(betterproto2.Message):
    block_info: "LightBlockInfo | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    deploys: "list[DeployInfoWithEventData]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    system_deploys: "list[SystemDeployInfoWithEventData]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    post_state_hash: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "BlockEventInfo", BlockEventInfo)


@dataclass(eq=False, repr=False)
class BlockHashMessageProto(betterproto2.Message):
    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    block_creator: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "BlockHashMessageProto", BlockHashMessageProto)


@dataclass(eq=False, repr=False)
class BlockInfo(betterproto2.Message):
    """
    For node clients, see BlockMessage for actual Casper protocol Block representation
    """

    block_info: "LightBlockInfo | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    deploys: "list[DeployInfo]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "BlockInfo", BlockInfo)


@dataclass(eq=False, repr=False)
class BlockMessageProto(betterproto2.Message):
    """
    ------- End Signing Protocol --------

    --------- Core Protocol  --------
    """

    block_hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    obtained by hashing the information in the header
    """

    header: "HeaderProto | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    body: "BodyProto | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True)

    justifications: "list[JustificationProto]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    map of all validators to latest blocks based on current view
    """

    sender: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    public key of the validator that created the block
    """

    seq_num: "int" = betterproto2.field(6, betterproto2.TYPE_INT32)
    """
    number of blocks created by the validator
    """

    sig: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)
    """
    signature generated by signing `hash(hash(justification) concat blockHash)`.
    """

    sig_algorithm: "str" = betterproto2.field(8, betterproto2.TYPE_STRING)
    """
    name of the algorithm used to sign
    """

    shard_id: "str" = betterproto2.field(9, betterproto2.TYPE_STRING)
    """
    identifier of the shard where the block was created
    """

    extra_bytes: "bytes" = betterproto2.field(10, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "BlockMessageProto", BlockMessageProto)


@dataclass(eq=False, repr=False)
class BlockMetadataInternal(betterproto2.Message):
    block_hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    parents: "list[bytes]" = betterproto2.field(2, betterproto2.TYPE_BYTES, repeated=True)

    sender: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    justifications: "list[JustificationProto]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)

    bonds: "list[BondProto]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)

    block_num: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)

    seq_num: "int" = betterproto2.field(7, betterproto2.TYPE_INT32)

    invalid: "bool" = betterproto2.field(8, betterproto2.TYPE_BOOL)
    """
    whether the block was marked as invalid
    """

    directly_finalized: "bool" = betterproto2.field(9, betterproto2.TYPE_BOOL)
    """
    whether the block has been last finalized block (LFB)
    """

    finalized: "bool" = betterproto2.field(10, betterproto2.TYPE_BOOL)
    """
    whether the block is finalized
    """


default_message_pool.register_message("casper", "BlockMetadataInternal", BlockMetadataInternal)


@dataclass(eq=False, repr=False)
class BlockQuery(betterproto2.Message):
    hash: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "BlockQuery", BlockQuery)


@dataclass(eq=False, repr=False)
class BlockRequestProto(betterproto2.Message):
    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "BlockRequestProto", BlockRequestProto)


@dataclass(eq=False, repr=False)
class BlocksQuery(betterproto2.Message):
    depth: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "BlocksQuery", BlocksQuery)


@dataclass(eq=False, repr=False)
class BlocksQueryByHeight(betterproto2.Message):
    start_block_number: "int" = betterproto2.field(1, betterproto2.TYPE_INT64)

    end_block_number: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "BlocksQueryByHeight", BlocksQueryByHeight)


@dataclass(eq=False, repr=False)
class BodyProto(betterproto2.Message):
    state: "RChainStateProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    deploys: "list[ProcessedDeployProto]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    system_deploys: "list[ProcessedSystemDeployProto]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)

    extra_bytes: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)

    rejected_deploys: "list[RejectedDeployProto]" = betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "BodyProto", BodyProto)


@dataclass(eq=False, repr=False)
class BondInfo(betterproto2.Message):
    validator: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    stake: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "BondInfo", BondInfo)


@dataclass(eq=False, repr=False)
class BondProto(betterproto2.Message):
    validator: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    stake: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "BondProto", BondProto)


@dataclass(eq=False, repr=False)
class BondStatusQuery(betterproto2.Message):
    public_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "BondStatusQuery", BondStatusQuery)


@dataclass(eq=False, repr=False)
class CloseBlockSystemDeployDataProto(betterproto2.Message):
    pass


default_message_pool.register_message("casper", "CloseBlockSystemDeployDataProto", CloseBlockSystemDeployDataProto)


@dataclass(eq=False, repr=False)
class CommEventProto(betterproto2.Message):
    consume: "ConsumeEventProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    produces: "list[ProduceEventProto]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    peeks: "list[PeekProto]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "CommEventProto", CommEventProto)


@dataclass(eq=False, repr=False)
class ConsumeEventProto(betterproto2.Message):
    channels_hashes: "list[bytes]" = betterproto2.field(1, betterproto2.TYPE_BYTES, repeated=True)

    hash: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    persistent: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)


default_message_pool.register_message("casper", "ConsumeEventProto", ConsumeEventProto)


@dataclass(eq=False, repr=False)
class ContinuationAtNameQuery(betterproto2.Message):
    depth: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    names: "list[_rhoapi__.Par]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "ContinuationAtNameQuery", ContinuationAtNameQuery)


@dataclass(eq=False, repr=False)
class ContinuationsWithBlockInfo(betterproto2.Message):
    post_block_continuations: "list[WaitingContinuationInfo]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    block: "LightBlockInfo | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "ContinuationsWithBlockInfo", ContinuationsWithBlockInfo)


@dataclass(eq=False, repr=False)
class DataAtNameByBlockQuery(betterproto2.Message):
    par: "_rhoapi__.Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    block_hash: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    use_pre_state_hash: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)


default_message_pool.register_message("casper", "DataAtNameByBlockQuery", DataAtNameByBlockQuery)


@dataclass(eq=False, repr=False)
class DataAtNameQuery(betterproto2.Message):
    depth: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    name: "_rhoapi__.Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "DataAtNameQuery", DataAtNameQuery)


@dataclass(eq=False, repr=False)
class DataWithBlockInfo(betterproto2.Message):
    post_block_data: "list[_rhoapi__.Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    block: "LightBlockInfo | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "DataWithBlockInfo", DataWithBlockInfo)


@dataclass(eq=False, repr=False)
class DeployDataProto(betterproto2.Message):
    """
    *
    Note: deploys are uniquely keyed by `user`, `timestamp`.

    **TODO**: details of signatures and payment. See RHOL-781
    """

    deployer: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    public key
    """

    term: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    rholang source code to deploy (will be parsed into `Par`)
    """

    timestamp: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)
    """
    millisecond timestamp
    """

    sig: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    signature of (hash(term) + timestamp) using private key
    """

    sig_algorithm: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    name of the algorithm used to sign
    """

    phlo_price: "int" = betterproto2.field(7, betterproto2.TYPE_INT64)
    """
    phlo price
    """

    phlo_limit: "int" = betterproto2.field(8, betterproto2.TYPE_INT64)
    """
    phlo limit for the deployment
    """

    valid_after_block_number: "int" = betterproto2.field(10, betterproto2.TYPE_INT64)

    shard_id: "str" = betterproto2.field(11, betterproto2.TYPE_STRING)
    """
    shard ID to prevent replay of deploys between shards
    """


default_message_pool.register_message("casper", "DeployDataProto", DeployDataProto)


@dataclass(eq=False, repr=False)
class DeployInfo(betterproto2.Message):
    deployer: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    term: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    timestamp: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)

    sig: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    sig_algorithm: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)

    phlo_price: "int" = betterproto2.field(7, betterproto2.TYPE_INT64)

    phlo_limit: "int" = betterproto2.field(8, betterproto2.TYPE_INT64)

    valid_after_block_number: "int" = betterproto2.field(9, betterproto2.TYPE_INT64)

    cost: "int" = betterproto2.field(10, betterproto2.TYPE_UINT64)

    errored: "bool" = betterproto2.field(11, betterproto2.TYPE_BOOL)

    system_deploy_error: "str" = betterproto2.field(12, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "DeployInfo", DeployInfo)


@dataclass(eq=False, repr=False)
class DeployInfoWithEventData(betterproto2.Message):
    deploy_info: "DeployInfo | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    report: "list[SingleReport]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "DeployInfoWithEventData", DeployInfoWithEventData)


@dataclass(eq=False, repr=False)
class EventProto(betterproto2.Message):
    """


    Oneofs:
        - event_instance:
    """

    produce: "ProduceEventProto | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="event_instance"
    )

    consume: "ConsumeEventProto | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="event_instance"
    )

    comm: "CommEventProto | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="event_instance"
    )


default_message_pool.register_message("casper", "EventProto", EventProto)


@dataclass(eq=False, repr=False)
class ExploratoryDeployQuery(betterproto2.Message):
    term: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    block_hash: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    use_pre_state_hash: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)


default_message_pool.register_message("casper", "ExploratoryDeployQuery", ExploratoryDeployQuery)


@dataclass(eq=False, repr=False)
class FindDeployQuery(betterproto2.Message):
    deploy_id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "FindDeployQuery", FindDeployQuery)


@dataclass(eq=False, repr=False)
class ForkChoiceTipRequestProto(betterproto2.Message):
    pass


default_message_pool.register_message("casper", "ForkChoiceTipRequestProto", ForkChoiceTipRequestProto)


@dataclass(eq=False, repr=False)
class HasBlockProto(betterproto2.Message):
    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "HasBlockProto", HasBlockProto)


@dataclass(eq=False, repr=False)
class HasBlockRequestProto(betterproto2.Message):
    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "HasBlockRequestProto", HasBlockRequestProto)


@dataclass(eq=False, repr=False)
class HeaderProto(betterproto2.Message):
    parents_hash_list: "list[bytes]" = betterproto2.field(1, betterproto2.TYPE_BYTES, repeated=True)
    """
    list of parent block hashes
    """

    timestamp: "int" = betterproto2.field(5, betterproto2.TYPE_INT64)

    version: "int" = betterproto2.field(6, betterproto2.TYPE_INT64)

    extra_bytes: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "HeaderProto", HeaderProto)


@dataclass(eq=False, repr=False)
class IsFinalizedQuery(betterproto2.Message):
    hash: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "IsFinalizedQuery", IsFinalizedQuery)


@dataclass(eq=False, repr=False)
class JustificationInfo(betterproto2.Message):
    validator: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    latest_block_hash: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "JustificationInfo", JustificationInfo)


@dataclass(eq=False, repr=False)
class JustificationProto(betterproto2.Message):
    validator: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    latest_block_hash: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "JustificationProto", JustificationProto)


@dataclass(eq=False, repr=False)
class LastFinalizedBlockQuery(betterproto2.Message):
    pass


default_message_pool.register_message("casper", "LastFinalizedBlockQuery", LastFinalizedBlockQuery)


@dataclass(eq=False, repr=False)
class LightBlockInfo(betterproto2.Message):
    block_hash: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    BlockMessageProto message
    """

    sender: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    seq_num: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)

    sig: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    sig_algorithm: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)

    shard_id: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)

    extra_bytes: "bytes" = betterproto2.field(7, betterproto2.TYPE_BYTES)

    version: "int" = betterproto2.field(8, betterproto2.TYPE_INT64)
    """
    HeaderProto message
    """

    timestamp: "int" = betterproto2.field(9, betterproto2.TYPE_INT64)

    header_extra_bytes: "bytes" = betterproto2.field(10, betterproto2.TYPE_BYTES)

    parents_hash_list: "list[str]" = betterproto2.field(11, betterproto2.TYPE_STRING, repeated=True)

    block_number: "int" = betterproto2.field(12, betterproto2.TYPE_INT64)
    """
    BodyProto message
    """

    pre_state_hash: "str" = betterproto2.field(13, betterproto2.TYPE_STRING)

    post_state_hash: "str" = betterproto2.field(14, betterproto2.TYPE_STRING)

    body_extra_bytes: "bytes" = betterproto2.field(15, betterproto2.TYPE_BYTES)

    bonds: "list[BondInfo]" = betterproto2.field(16, betterproto2.TYPE_MESSAGE, repeated=True)

    block_size: "str" = betterproto2.field(17, betterproto2.TYPE_STRING)
    """
    extra
    """

    deploy_count: "int" = betterproto2.field(18, betterproto2.TYPE_INT32)

    fault_tolerance: "float" = betterproto2.field(19, betterproto2.TYPE_FLOAT)

    justifications: "list[JustificationInfo]" = betterproto2.field(20, betterproto2.TYPE_MESSAGE, repeated=True)

    rejected_deploys: "list[RejectedDeployInfo]" = betterproto2.field(21, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "LightBlockInfo", LightBlockInfo)


@dataclass(eq=False, repr=False)
class MachineVerifyQuery(betterproto2.Message):
    pass


default_message_pool.register_message("casper", "MachineVerifyQuery", MachineVerifyQuery)


@dataclass(eq=False, repr=False)
class NoApprovedBlockAvailableProto(betterproto2.Message):
    identifier: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    node_identifer: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "NoApprovedBlockAvailableProto", NoApprovedBlockAvailableProto)


@dataclass(eq=False, repr=False)
class PeekProto(betterproto2.Message):
    channel_index: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "PeekProto", PeekProto)


@dataclass(eq=False, repr=False)
class PrivateNamePreviewQuery(betterproto2.Message):
    user: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    public key a la DeployData
    """

    timestamp: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)
    """
    millisecond timestamp
    """

    name_qty: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)
    """
    how many names to preview? (max: 1024)
    """


default_message_pool.register_message("casper", "PrivateNamePreviewQuery", PrivateNamePreviewQuery)


@dataclass(eq=False, repr=False)
class ProcessedDeployProto(betterproto2.Message):
    deploy: "DeployDataProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    cost: "_rhoapi__.PCost | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)

    deploy_log: "list[EventProto]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    the new terms and comm. rule reductions from this deploy
    """

    errored: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)
    """
    true if deploy encountered a user error
    """

    system_deploy_error: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "ProcessedDeployProto", ProcessedDeployProto)


@dataclass(eq=False, repr=False)
class ProcessedSystemDeployProto(betterproto2.Message):
    system_deploy: "SystemDeployDataProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    deploy_log: "list[EventProto]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    error_msg: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "ProcessedSystemDeployProto", ProcessedSystemDeployProto)


@dataclass(eq=False, repr=False)
class ProduceEventProto(betterproto2.Message):
    channels_hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    hash: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    persistent: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    times_repeated: "int" = betterproto2.field(4, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "ProduceEventProto", ProduceEventProto)


@dataclass(eq=False, repr=False)
class RChainStateProto(betterproto2.Message):
    pre_state_hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    hash of the tuplespace contents before new deploys
    """

    post_state_hash: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    hash of the tuplespace contents after new deploys
    """

    bonds: "list[BondProto]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    Internals of what will be the "blessed" PoS contract
    (which will be part of the tuplespace in the real implementation).
    """

    block_number: "int" = betterproto2.field(4, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "RChainStateProto", RChainStateProto)


@dataclass(eq=False, repr=False)
class RejectedDeployInfo(betterproto2.Message):
    sig: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "RejectedDeployInfo", RejectedDeployInfo)


@dataclass(eq=False, repr=False)
class RejectedDeployProto(betterproto2.Message):
    sig: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "RejectedDeployProto", RejectedDeployProto)


@dataclass(eq=False, repr=False)
class ReportCommProto(betterproto2.Message):
    consume: "ReportConsumeProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    produces: "list[ReportProduceProto]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "ReportCommProto", ReportCommProto)


@dataclass(eq=False, repr=False)
class ReportConsumeProto(betterproto2.Message):
    channels: "list[_rhoapi__.Par]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    patterns: "list[_rhoapi__.BindPattern]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    peeks: "list[PeekProto]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    """
    disable because can not work and it is not important actually
     TaggedContinuation continuation=3;
    """


default_message_pool.register_message("casper", "ReportConsumeProto", ReportConsumeProto)


@dataclass(eq=False, repr=False)
class ReportProduceProto(betterproto2.Message):
    channel: "_rhoapi__.Par | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    data: "_rhoapi__.ListParWithRandom | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "ReportProduceProto", ReportProduceProto)


@dataclass(eq=False, repr=False)
class ReportProto(betterproto2.Message):
    """


    Oneofs:
        - report:
    """

    produce: "ReportProduceProto | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="report"
    )

    consume: "ReportConsumeProto | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="report"
    )

    comm: "ReportCommProto | None" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="report")


default_message_pool.register_message("casper", "ReportProto", ReportProto)


@dataclass(eq=False, repr=False)
class ReportQuery(betterproto2.Message):
    hash: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    force_replay: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message("casper", "ReportQuery", ReportQuery)


@dataclass(eq=False, repr=False)
class Signature(betterproto2.Message):
    public_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    algorithm: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    sig: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "Signature", Signature)


@dataclass(eq=False, repr=False)
class SingleReport(betterproto2.Message):
    events: "list[ReportProto]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "SingleReport", SingleReport)


@dataclass(eq=False, repr=False)
class SlashSystemDeployDataProto(betterproto2.Message):
    invalid_block_hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    issuer_public_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "SlashSystemDeployDataProto", SlashSystemDeployDataProto)


@dataclass(eq=False, repr=False)
class Status(betterproto2.Message):
    version: "VersionInfo | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    address: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)

    network_id: "str" = betterproto2.field(3, betterproto2.TYPE_STRING)

    shard_id: "str" = betterproto2.field(4, betterproto2.TYPE_STRING)

    peers: "int" = betterproto2.field(5, betterproto2.TYPE_INT32)

    nodes: "int" = betterproto2.field(6, betterproto2.TYPE_INT32)

    min_phlo_price: "int" = betterproto2.field(7, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "Status", Status)


@dataclass(eq=False, repr=False)
class StoreItemProto(betterproto2.Message):
    key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    value: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message("casper", "StoreItemProto", StoreItemProto)


@dataclass(eq=False, repr=False)
class StoreItemsMessageProto(betterproto2.Message):
    start_path: "list[StoreNodeKeyProto]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    last_path: "list[StoreNodeKeyProto]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)

    history_items: "list[StoreItemProto]" = betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)

    data_items: "list[StoreItemProto]" = betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "StoreItemsMessageProto", StoreItemsMessageProto)


@dataclass(eq=False, repr=False)
class StoreItemsMessageRequestProto(betterproto2.Message):
    start_path: "list[StoreNodeKeyProto]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    skip: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)

    take: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "StoreItemsMessageRequestProto", StoreItemsMessageRequestProto)


@dataclass(eq=False, repr=False)
class StoreNodeKeyProto(betterproto2.Message):
    """
    --------- Last finalized state  --------
    """

    hash: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    index: "int" = betterproto2.field(2, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "StoreNodeKeyProto", StoreNodeKeyProto)


@dataclass(eq=False, repr=False)
class SystemDeployDataProto(betterproto2.Message):
    """


    Oneofs:
        - systemDeploy:
    """

    slash_system_deploy: "SlashSystemDeployDataProto | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="systemDeploy"
    )

    close_block_system_deploy: "CloseBlockSystemDeployDataProto | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="systemDeploy"
    )


default_message_pool.register_message("casper", "SystemDeployDataProto", SystemDeployDataProto)


@dataclass(eq=False, repr=False)
class SystemDeployInfoWithEventData(betterproto2.Message):
    system_deploy: "SystemDeployDataProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    report: "list[SingleReport]" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)


default_message_pool.register_message("casper", "SystemDeployInfoWithEventData", SystemDeployInfoWithEventData)


@dataclass(eq=False, repr=False)
class UnapprovedBlockProto(betterproto2.Message):
    candidate: "ApprovedBlockCandidateProto | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    timestamp: "int" = betterproto2.field(2, betterproto2.TYPE_INT64)

    duration: "int" = betterproto2.field(3, betterproto2.TYPE_INT64)


default_message_pool.register_message("casper", "UnapprovedBlockProto", UnapprovedBlockProto)


@dataclass(eq=False, repr=False)
class VersionInfo(betterproto2.Message):
    api: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    node: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)


default_message_pool.register_message("casper", "VersionInfo", VersionInfo)


@dataclass(eq=False, repr=False)
class VisualizeDagQuery(betterproto2.Message):
    depth: "int" = betterproto2.field(1, betterproto2.TYPE_INT32)

    show_justification_lines: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)

    start_block_number: "int" = betterproto2.field(3, betterproto2.TYPE_INT32)


default_message_pool.register_message("casper", "VisualizeDagQuery", VisualizeDagQuery)


@dataclass(eq=False, repr=False)
class WaitingContinuationInfo(betterproto2.Message):
    post_block_patterns: "list[_rhoapi__.BindPattern]" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)

    post_block_continuation: "_rhoapi__.Par | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("casper", "WaitingContinuationInfo", WaitingContinuationInfo)


from .. import rhoapi as _rhoapi__
